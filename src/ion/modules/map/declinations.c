/* Autogenerated file. Do not edit. */ typedef struct { u64 capacity; u64 length; u64* hashes; i32* keys; i32* values; u64 load_limit; memory* allocator; padding(8); } map(i32, i32); check_sizeof(map(i32, i32), 64); typedef struct { i32* key; i32* value; u64 index; u64 hash; } map_iterator(i32, i32); check_sizeof(map_iterator(i32, i32), 32);; static inline u64 map_hasher(i32, i32) ( i32* key ); static inline bool map_comparer(i32, i32) ( i32* k1, i32* k2 ); i32* map_del(i32, i32) ( map(i32, i32)* m, i32* key ); i32* map_get(i32, i32) ( map(i32, i32)* m, i32* key ); map(i32, i32) map_init(i32, i32) ( u64 initial_capacity, memory* allocator ); void map_rehash(i32, i32) ( map(i32, i32)* m ); i32* map_set(i32, i32) ( map(i32, i32)* m, i32* key, i32* value ); i32* map_del(i32, i32) ( map(i32, i32)* m, i32* key ) { u64 key_hash = map_hasher(i32, i32)(key); u64 probe_index = key_hash & (m->capacity - 1); u64 probe_index_limit = m->capacity + MAP_CAPACITY_PADDING - 1; linear_probing: if (map_comparer(i32, i32)(key, map_key_at(m, probe_index))) { map_entry_free(m, probe_index); return map_value_at(m, probe_index); } if (map_entry_is_empty(m, probe_index)) return NULL; probe_index++; if (probe_index >= probe_index_limit) probe_index = 0; goto linear_probing; }; i32* map_get(i32, i32) ( map(i32, i32)* m, i32* key ) { u64 key_hash = map_hasher(i32, i32)(key); u64 probe_index = key_hash & (m->capacity - 1); u64 probe_index_limit = m->capacity + MAP_CAPACITY_PADDING - 1; linear_probing: if (map_comparer(i32, i32)(key, map_key_at(m, probe_index))) return map_value_at(m, probe_index); if (map_entry_is_empty(m, probe_index)) return NULL; probe_index++; if (probe_index >= probe_index_limit) probe_index = 0; goto linear_probing; }; map(i32, i32) map_init(i32, i32) ( u64 initial_capacity, memory* allocator ) { u64 capacity = next_pow2(initial_capacity); if (capacity < MAP_CAPACITY_DEFAULT) capacity = MAP_CAPACITY_DEFAULT; u64 padded_capacity = capacity + MAP_CAPACITY_PADDING; map(i32, i32) m = { .capacity = capacity, .length = 0, .hashes = memory_alloc_zero(allocator, padded_capacity * sizeof(u64)), .keys = memory_alloc_zero(allocator, padded_capacity * sizeof(i32)), .values = memory_alloc_zero(allocator, padded_capacity * sizeof(i32)), .load_limit = map_load_limit(capacity), .allocator = allocator, }; return m; }; void map_rehash(i32, i32) ( map(i32, i32)* m ) { u64 new_capacity = m->capacity * 2; map(i32, i32) rehashed_map = map_init(i32, i32)(new_capacity, m->allocator); for (u64 i = 0; i < m->capacity + MAP_CAPACITY_PADDING; i++) { if (map_entry_is_empty(m, i)) continue; i32* key = map_key_at(m, i); i32* value = map_value_at(m, i); map_set(i32, i32)(&rehashed_map, key, value); } m->capacity = new_capacity; m->hashes = rehashed_map.hashes; m->keys = rehashed_map.keys; m->values = rehashed_map.values; m->load_limit = map_load_limit(new_capacity); }; i32* map_set(i32, i32) ( map(i32, i32)* m, i32* key, i32* value ) { u64 key_hash = map_hasher(i32, i32)(key); u64 probe_index = key_hash & (m->capacity - 1); u64 probe_index_limit = m->capacity + MAP_CAPACITY_PADDING - 1; linear_probing: i32* probed_key = map_key_at(m, probe_index); if (map_entry_is_empty(m, probe_index)) goto set_value_new; if (map_comparer(i32, i32)(key, probed_key)) goto set_value_existing; probe_index++; if (probe_index >= probe_index_limit) probe_index = 0; goto linear_probing; set_value_new: *probed_key = *key; map_entry_occupy(m, probe_index, key_hash); m->length++; set_value_existing: *map_value_at(m, probe_index) = *value; if (m->length >= m->load_limit) map_rehash(i32, i32)(m); return value; };;;
static inline bool map_comparer(i32, i32) (
    i32* k1,
    i32* k2
)
{
  return *k1 == *k2;
}
static inline u64 map_hasher(i32, i32) (
    i32* key
)
{
  return (u64) *key;
}
